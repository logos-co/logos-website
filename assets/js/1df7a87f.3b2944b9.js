"use strict";(self.webpackChunklogos_docs=self.webpackChunklogos_docs||[]).push([[781],{8089:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>a});var o=s(4848),l=s(8453);const i={title:"Interacting with the Library",description:"How clients communicate with liblogos at runtime."},r="Interacting with liblogos",c={id:"liblogos/interacting-with-the-library",title:"Interacting with the Library",description:"How clients communicate with liblogos at runtime.",source:"@site/docs/liblogos/interacting-with-the-library.md",sourceDirName:"liblogos",slug:"/liblogos/interacting-with-the-library",permalink:"/logos-website/docs/liblogos/interacting-with-the-library",draft:!1,unlisted:!1,editUrl:"https://github.com/logos-co/logos-website/edit/main/website/docs/liblogos/interacting-with-the-library.md",tags:[],version:"current",frontMatter:{title:"Interacting with the Library",description:"How clients communicate with liblogos at runtime."},sidebar:"docs",previous:{title:"Building Apps",permalink:"/logos-website/docs/logos-app/building-apps"},next:{title:"How to Create a Module",permalink:"/logos-website/docs/liblogos/how-to-create-a-module"}},t={},a=[{value:"C API",id:"c-api",level:2},{value:"Example (C)",id:"example-c",level:2},{value:"Example (JavaScript via FFI)",id:"example-javascript-via-ffi",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"interacting-with-liblogos",children:"Interacting with liblogos"}),"\n",(0,o.jsxs)(n.p,{children:["The Logos Core library (",(0,o.jsx)(n.code,{children:"liblogos_core"}),") exposes a small C API for initializing the core, managing plugins, invoking plugin methods asynchronously, and subscribing to plugin events."]}),"\n",(0,o.jsx)(n.h2,{id:"c-api",children:"C API"}),"\n",(0,o.jsxs)(n.p,{children:["Include header: ",(0,o.jsx)(n.code,{children:"logos-liblogos/src/logos_core.h"})]}),"\n",(0,o.jsx)(n.p,{children:"Lifecycle"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c",children:"void logos_core_init(int argc, char *argv[]);\nvoid logos_core_set_plugins_dir(const char* plugins_dir);\nvoid logos_core_start();\nint  logos_core_exec();                // Run Qt event loop (blocking)\nvoid logos_core_cleanup();\n"})}),"\n",(0,o.jsx)(n.p,{children:"Descriptions"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_init"})," \u2014 Creates the internal ",(0,o.jsx)(n.code,{children:"QCoreApplication"})," and prepares the core. Call this first (you can pass your process ",(0,o.jsx)(n.code,{children:"argc/argv"})," or ",(0,o.jsx)(n.code,{children:"0,NULL"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_set_plugins_dir"})," \u2014 Overrides the directory scanned for modules before ",(0,o.jsx)(n.code,{children:"start"}),". If not set, defaults to ",(0,o.jsx)(n.code,{children:"../modules"})," relative to the binary."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_start"})," \u2014 Initializes the Qt Remote Objects registry, discovers and processes plugins in the plugins directory, and bootstraps internal modules (e.g., core manager). Does not block."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_exec"})," \u2014 Enters the Qt event loop and blocks until quit. Use either this or periodic ",(0,o.jsx)(n.code,{children:"logos_core_process_events()"}),"\u2014not both."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_cleanup"})," \u2014 Stops all plugin processes, tears down internal state and the registry host, and destroys the application instance."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Plugin management"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c",children:"char** logos_core_get_loaded_plugins(); // Null-terminated array; caller frees\nchar** logos_core_get_known_plugins();  // Null-terminated array; caller frees\nint    logos_core_load_plugin(const char* plugin_name);   // 1 success, 0 fail\nint    logos_core_unload_plugin(const char* plugin_name); // 1 success, 0 fail\nchar*  logos_core_process_plugin(const char* plugin_path); // Returns plugin name or NULL; caller frees\nchar*  logos_core_get_token(const char* key); // Experimental; caller frees\n"})}),"\n",(0,o.jsx)(n.p,{children:"Descriptions"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_get_loaded_plugins"})," \u2014 Returns names of currently running plugins. The result is a null-terminated ",(0,o.jsx)(n.code,{children:"char**"})," allocated with ",(0,o.jsx)(n.code,{children:"new[]"}),"; delete each entry and the array with ",(0,o.jsx)(n.code,{children:"delete[]"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_get_known_plugins"})," \u2014 Returns names discovered/processed in the plugins directory, whether loaded or not. Same allocation/ownership as above."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_load_plugin"})," \u2014 Starts the plugin process by name (must be in known plugins). Returns ",(0,o.jsx)(n.code,{children:"1"})," on success, ",(0,o.jsx)(n.code,{children:"0"})," on failure."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_unload_plugin"})," \u2014 Terminates the plugin process and removes it from the loaded list. Returns ",(0,o.jsx)(n.code,{children:"1"})," on success, ",(0,o.jsx)(n.code,{children:"0"})," on failure."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_process_plugin"})," \u2014 Parses a plugin file at ",(0,o.jsx)(n.code,{children:"plugin_path"}),", adds it to the known list, and returns the discovered plugin name, or ",(0,o.jsx)(n.code,{children:"NULL"})," on error. The returned ",(0,o.jsx)(n.code,{children:"char*"})," is allocated with ",(0,o.jsx)(n.code,{children:"new[]"}),"; free with ",(0,o.jsx)(n.code,{children:"delete[]"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_get_token"})," \u2014 Experimental helper to fetch a token by key from the core token manager. Returns a ",(0,o.jsx)(n.code,{children:"char*"})," allocated with ",(0,o.jsx)(n.code,{children:"new[]"})," or ",(0,o.jsx)(n.code,{children:"NULL"})," if not found; free with ",(0,o.jsx)(n.code,{children:"delete[]"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Async operations and events"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c",children:"typedef void (*AsyncCallback)(int result, const char* message, void* user_data);\n\nvoid logos_core_async_operation(const char* data,\n                                AsyncCallback cb,\n                                void* user_data);\n\n// params_json: JSON array of {name, value, type}\nvoid logos_core_call_plugin_method_async(const char* plugin_name,\n                                         const char* method_name,\n                                         const char* params_json,\n                                         AsyncCallback cb,\n                                         void* user_data);\n\nvoid logos_core_register_event_listener(const char* plugin_name,\n                                        const char* event_name,\n                                        AsyncCallback cb,\n                                        void* user_data);\n\n// Non-blocking event pump (useful if you manage your own loop)\nvoid logos_core_process_events();\n"})}),"\n",(0,o.jsx)(n.p,{children:"Descriptions"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"AsyncCallback"})," \u2014 Callback signature used by all async operations. ",(0,o.jsx)(n.code,{children:"result"})," is ",(0,o.jsx)(n.code,{children:"1"})," (success) or ",(0,o.jsx)(n.code,{children:"0"})," (error). ",(0,o.jsx)(n.code,{children:"message"})," contains the payload or error text. Treat ",(0,o.jsx)(n.code,{children:"message"})," as read\u2011only and copy it if you need it after the callback returns."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_async_operation"})," \u2014 Simple test/utility async op; invokes the callback after a short delay with a success message. Useful for wiring checks."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_call_plugin_method_async"})," \u2014 Invokes a method on a loaded plugin. ",(0,o.jsx)(n.code,{children:"params_json"})," is a JSON array of ",(0,o.jsx)(n.code,{children:"{name, value, type}"}),". Supported ",(0,o.jsx)(n.code,{children:"type"})," values: ",(0,o.jsx)(n.code,{children:"string"}),", ",(0,o.jsx)(n.code,{children:"int|integer"}),", ",(0,o.jsx)(n.code,{children:"bool|boolean"}),", ",(0,o.jsx)(n.code,{children:"double|float"})," (unknown types default to string). On completion, calls the callback with result or error text."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_register_event_listener"})," \u2014 Subscribes to a plugin event. When the event fires, the callback receives a JSON string like ",(0,o.jsx)(n.code,{children:'{"event":"<name>","data":[...]}"'})," in ",(0,o.jsx)(n.code,{children:"message"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"logos_core_process_events"})," \u2014 Processes Qt events without blocking; call this regularly if you are not using ",(0,o.jsx)(n.code,{children:"logos_core_exec()"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Notes"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The async callbacks receive ",(0,o.jsx)(n.code,{children:"(result, message, user_data)"}),". For method calls, ",(0,o.jsx)(n.code,{children:"message"})," is either the result payload or an error description. For events, ",(0,o.jsx)(n.code,{children:"message"})," is a JSON string like ",(0,o.jsx)(n.code,{children:'{ "event": "name", "data": [...] }'}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Use ",(0,o.jsx)(n.code,{children:"logos_core_exec()"})," for a blocking Qt event loop, or call ",(0,o.jsx)(n.code,{children:"logos_core_process_events()"})," periodically from your own loop."]}),"\n",(0,o.jsxs)(n.li,{children:["Memory ownership: arrays and strings returned by the API are allocated with ",(0,o.jsx)(n.code,{children:"new[]"}),". Free with ",(0,o.jsx)(n.code,{children:"delete[]"})," (delete each string, then the array)."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"example-c",children:"Example (C)"}),"\n",(0,o.jsx)(n.p,{children:"Minimal C program that initializes the core, loads plugins, subscribes to an event, and calls a plugin method asynchronously."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n#include <string.h>\n#include "logos_core.h"\n\nstatic void on_async(int result, const char* message, void* user_data) {\n    const char* tag = (const char*)user_data;\n    printf("[%s] result=%d message=%s\\n", tag ? tag : "cb", result, message ? message : "");\n}\n\nint main() {\n    // 1) Init and start core\n    logos_core_init(0, NULL);\n    logos_core_set_plugins_dir("./build/plugins"); // Adjust to your plugins output dir\n    logos_core_start();\n\n    // 2) Discover and load plugins\n    // If you have plugin files, you can process them directly:\n    // logos_core_process_plugin("./build/plugins/chat.plugin");\n    // Otherwise, load by name if the core already knows them:\n    if (!logos_core_load_plugin("waku_module")) {\n        printf("Failed to load waku_module\\n");\n    }\n    if (!logos_core_load_plugin("chat")) {\n        printf("Failed to load chat\\n");\n    }\n\n    // 3) Register an event listener (e.g., chatMessage from chat plugin)\n    logos_core_register_event_listener("chat", "chatMessage", on_async, (void*)"event");\n\n    // 4) Call a plugin method asynchronously\n    // Example: joinChannel(channelName: string)\n    const char* params = "[{\\"name\\":\\"channelName\\",\\"value\\":\\"general\\",\\"type\\":\\"string\\"}]";\n    logos_core_call_plugin_method_async("chat", "joinChannel", params, on_async, (void*)"call");\n\n    // 5) Pump events for a bit (or call logos_core_exec() to block)\n    for (int i = 0; i < 200; i++) {\n        logos_core_process_events();\n        // Simple sleep; replace with your loop\'s timing\n        #ifdef _WIN32\n            Sleep(50);\n        #else\n            usleep(50 * 1000);\n        #endif\n    }\n\n    // 6) Cleanup\n    logos_core_cleanup();\n    return 0;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Build notes"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Link against the shared library: ",(0,o.jsx)(n.code,{children:"-llogos_core"})," (Linux), ",(0,o.jsx)(n.code,{children:"-llogos_core"})," with proper ",(0,o.jsx)(n.code,{children:"-L"})," path (macOS), or ",(0,o.jsx)(n.code,{children:"logos_core.lib"})," (Windows)."]}),"\n",(0,o.jsxs)(n.li,{children:["Ensure the runtime loader can find the library (",(0,o.jsx)(n.code,{children:"LD_LIBRARY_PATH"}),", ",(0,o.jsx)(n.code,{children:"DYLD_LIBRARY_PATH"}),", or system path settings)."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"example-javascript-via-ffi",children:"Example (JavaScript via FFI)"}),"\n",(0,o.jsxs)(n.p,{children:["You can use Node.js FFI to call the C API directly. The snippet below uses ",(0,o.jsx)(n.code,{children:"ffi-napi"})," and ",(0,o.jsx)(n.code,{children:"ref-napi"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Install dependencies"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"npm install ffi-napi ref-napi\n"})}),"\n",(0,o.jsx)(n.p,{children:"Bind and call the library"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const ffi = require('ffi-napi');\nconst ref = require('ref-napi');\n\n// Resolve the library file for your OS\n// Linux:   ./build/liblogos_core.so\n// macOS:   ./build/liblogos_core.dylib\n// Windows: .\\\\build\\\\logos_core.dll\nconst libPath = process.env.LOGOS_CORE_LIB || './build/liblogos_core.dylib';\n\n// Define the callback type: void (*)(int, const char*, void*)\nconst AsyncCallback = ffi.Function('void', ['int', 'string', 'void*']);\n\nconst logos = ffi.Library(libPath, {\n  // lifecycle\n  logos_core_init: ['void', ['int', 'pointer']],\n  logos_core_set_plugins_dir: ['void', ['string']],\n  logos_core_start: ['void', []],\n  logos_core_cleanup: ['void', []],\n\n  // async ops\n  logos_core_call_plugin_method_async: ['void', ['string', 'string', 'string', AsyncCallback, 'void*']],\n  logos_core_register_event_listener: ['void', ['string', 'string', AsyncCallback, 'void*']],\n  logos_core_process_events: ['void', []],\n});\n\n// Create callbacks\nconst onEvent = ffi.Callback('void', ['int', 'string', 'void*'], (result, message, userData) => {\n  console.log('[event]', { result, message });\n});\n\nconst onCall = ffi.Callback('void', ['int', 'string', 'void*'], (result, message, userData) => {\n  console.log('[call]', { result, message });\n});\n\n// Init and start core\nlogos.logos_core_init(0, ref.NULL);\nlogos.logos_core_set_plugins_dir('./build/plugins');\nlogos.logos_core_start();\n\n// Register event listener and call a method\nlogos.logos_core_register_event_listener('chat', 'chatMessage', onEvent, ref.NULL);\n\nconst params = JSON.stringify([\n  { name: 'channelName', value: 'general', type: 'string' },\n]);\nlogos.logos_core_call_plugin_method_async('chat', 'joinChannel', params, onCall, ref.NULL);\n\n// Pump events periodically (Qt event loop integration)\nconst timer = setInterval(() => {\n  logos.logos_core_process_events();\n}, 50);\n\n// Later, when shutting down\nprocess.on('SIGINT', () => {\n  clearInterval(timer);\n  logos.logos_core_cleanup();\n  process.exit(0);\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"Tips"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["If you prefer a higher-level interface, see the JavaScript SDK at ",(0,o.jsx)(n.code,{children:"website/docs/sdks/javascript-sdk.md"}),", which wraps these FFI calls and adds a reflective API for plugin methods and events."]}),"\n",(0,o.jsxs)(n.li,{children:["Always call ",(0,o.jsx)(n.code,{children:"logos_core_process_events()"})," on an interval (or use the SDK\u2019s helper) so callbacks and events are delivered."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var o=s(6540);const l={},i=o.createContext(l);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);